package BinarySearch;

public class SingleElementInSortedArray {
    /**
     * TC : BIG O(N)
     * SC : BIG O(1)
     */
    public static int singleNonDuplicateBrute(int[] nums) {

        int n = nums.length;

        int x = nums[0];

        for(int i=1;i<n;i++) {
            x ^= nums[i];
        }

        return x;
    }

    public int singleNonDuplicate(int[] nums) {

        int n = nums.length;

        int low = 0;
        int high = n-2;
        int mid = 0;
        while(low <= high) {
            mid = low + (high-low)/2;

            if(nums[mid] == nums[mid^1])
                low = mid+1;
            else
                high = mid-1;
        }
        return nums[low];
    }

    /**
     * BRUTE APPROACH
     *
     * SIMPLY XOR EVERY ELEMENT, SINCE THERE ARE 2 ELEMENTS PRESENT AND ONLY 1 ELEMENT IS SINGLE, XOR WOULD BE LEFT WITH THAT
     * EXACT ELEMENT.
     *
     * OPTIMAL APPROACH
     *
     * WE WILL USE BINARY SEARCH. UPON OBSERVATION ONE THING WE CAN SEE IS SAY FOR ARRAY 1 1 2 2 3 4 4 5 5, THERE IS
     * LEFT PART 1 1 2 2 , AND RIGHT PART 4 4 5 5, IN THE LEFT PART EVEN INDEX COMES FIRST, THEN ODD INDEX,
     * MEANS THAT IF WE CHECK FOR SAY 1ST INDEX WHICH IS ONE AND ODD, IF WE CHECK ITS LEFT EVEN INDEX, ITS SAME, MEANS
     * WE ARE AT LEFT PART, WHEREAS FOR RIGHT PART, IF WE CHECK ODD INDEX 5 IS 4 BUT ITS LEFT MOST EVEN INDEX ISNT 4, MEANS
     * WE ARE AT RIGHT PART. NOW IF WE CAN SHRINK THE SEARCH SPACE SUCH THAT LOW BECOMES BIGGER THAN HIGH, THEN WE WILL
     * GET THE EXACT DUPLICATE ELEMENT INDEX.
     *
     * STEPS
     *
     * WE WILL HAVE LOW = 0 AND HIGH = N-2, WHY NOT N-1, BECAUSE LETS SAY WE DONT HAVE A RIGHT HALF, LIKE 1 1 2 2 3. IN THIS
     * CASE LOW WILL PASS HIGH AT 3RD INDEX, MEANS WE WILL TRY TO SHRINK THE LEFT HALF, OUR LOW WILL ULTIMATELY
     * HAVE VALUE AS 4TH INDEX.
     *
     * RUN WHILE LOOP TILL LOW IS <= HIGH.
     *
     * NOW WITH THE HELP OF XOR, IF WE ARE AT ODD INDEX, IT WILL GIVE US EVEN INDEX BEFORE IT, AND IF WE ARE AT EVEN INDEX
     * WE WILL GET ODD INDEX AFTER IT, INSTEAD OF WRITE FOR BOTH EVEN AND ODD INSTANCES, WE WILL USE ^
     *
     * NOW WHAT WE WILL TRY TO CHECK IF WE ARE AT LEFT SIDE, OR RIGHT SIDE, TO DO THIS SIMPLY COMPARE ARR[MID] == ARR[MID^1]
     * IT WILL RETURN TRUE, IF WE ARE AT LEFT PART, WHY? BECAUSE IT WILL CHECK RIGHT TO IT, IF IT IS THE CASE THEN SHRINK
     * LEFT SPACE AND PUT IT AS MID+1.
     *
     * ELSE TO CHECK FOR RIGHT PART, MEANS THE ABOVE FAILS. THAT IS BECAUSE IT WAS AT ODD INDEX AND IT CHECK FOR ELEMENT LEFT
     * TO IT VIA XOR, BECAUSE FOR ODD INDEX XOR, IT RETURN VALUE 1 SMALLER THAN IT UNLIKE FOR EVEN IT RETURNS GREATER, SINCE
     * IN RIGHT PART SAY FOR EG 1 1 2 3 3 4 4, WE CAN CONFIRM THE ODD INDEX COMES FIRST AND THEN EVEN INDEX, SO IF WE
     * ARE AT RIGHT PART, SHRINK RIGHT BY MID-1.
     *
     * IN THE END WHEN LOW <= HIGH, BECOMES FALSE AND BREAKS LOOP RETURN ARR[LOW] WHICH IS DUPLICATE ELEMENT.
     */
}
